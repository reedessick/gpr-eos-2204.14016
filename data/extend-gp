#!/usr/bin/env python3

"""extend an existing GP model to higher densities and pressures
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os

import h5py
import numpy as np

from argparse import ArgumentParser

#-------------------------------------------------

def kernel(x1, x2, **kwargs):
    raise NotImplementedError

#-------------------------------------------------

parser = ArgumentParser()

#---

cgroup = parser.add_argument_group('arguments for process that we wish to extend')

cgroup.add_argument('input_hdf', type=str)
cgroup.add_argument('--max-input-pressurec2', default=None, type=float,
    help='truncate the input process to be below this pressure. Should be supplied in CGS units (g/cm^3)')

#---

egroup = parser.add_argument_group('arguments for extension to higher density')

egroup.add_argument('--pressurec2-scale', default='log', type=str,
    help='either "linear" or "log"; defines how we compute covariance kernel for extension to higher pressures')

egroup.add_argument('--max-output-pressurec2', default=1e17, type=float)
egroup.add_argument('--num-pressurec2-points-per-length', default=10, type=int,
    help='the number of grid points to be placed per correlation length in the extension to higher pressures')

egroup.add_argument('--prior-standard-deviation', default=1.0, type=float,
    help='1D marginal standard deviation for auxiliary variable as part of extension to higher pressures')
egroup.add_argument('--prior-correlation-length', default=0.5, type=float,
    help='correlation length for auxiliary variable as part of extension to higher pressures')

### FIXME! add parameters for Matern kernel, also kernel type (squared exponential, matern, etc)

#---

vgroup = parser.add_argument_group('output arguments')

vgroup.add_argument('--output-hdf', type=str, default=None)
vgroup.add_argument('-v', '--verbose', default=False, action='store_true')

#---

args = parser.parse_args()

if args.output_hdf is None:
    args.output_hdf = 'extended_'+os.path.basename(args.input_hdf)

#-------------------------------------------------

if args.verbose:
    print('loading : '+args.input_hdf)

with h5py.File(args.input_hdf, 'r') as obj:
    group = obj[list(obj.keys())[0]]

    attrs = dict(group.attrs.items())

    input_pc2 = np.mean(group['mean']['log(pressurec2)'][:])
    input_phi = group['mean']['phi'][:] # for the moment, stick with the assumption that the maximum sound speed is 1

    input_cov = group['cov'][...]

#------------------------

# truncated initial process at user-defined maximum pressure
if args.max_input_pressurec2 is not None:
    max_input_pc2 = np.max(mean_pc2)

    if max_input_pc2 > args.max_input_pressurec2:
        if args.verbose:
            print('truncating input pressurec2 to be <= %.6e g/cm^3'%args.max_input_pressurec2)
        keep = input_pc2 <= args.max_input_pressurec2

        input_pc2 = input_pc2[keep]
        input_phi = input_phi[keep]
        input_cov = input_cov[keep,keep]

    elif args.verbose:
        print('maximum input pressurece (%.6e g/cm^3) already less than requested maximum (%.6e g/cm^3)' % \
            (max_input_pc2, args.max_input_pressurec2))

#-------------------------------------------------

# now set up additional pressure grid
low_pressurec2 = np.max(mean_pc2)

if args.pressurec2_scale == 'linear':
    num = (args.max_output_pressurec2 - low_pressurec2) / args.prior_correlation_length
    num *= args.num_pressurec2_points_per_length
    if args.verbose:
        print('placing extension to higher pressures linearly with %d points between (%.6e, %.6e) g/cm^3' % \
            (num, low_pressurec2, args.max_output_pressurec2))
    extra_pc2 = np.linspace(low_pressurec2, args.max_output_pressurec2, num+1)[1:] ### do not repeat first point

elif args.pressurec2_scale == 'log':
    num = np.log(args.max_output_pressurec2 / low_pressurec2) / args.prior_correlation_length)
    num *= args.num_pressurec2_points_per_length
    if args.verbose:
        print('placing extension to higher pressures logarithmically with %d points between (%.6e, %.6e) g/cm^3' % \
            (num, low_pressurec2, args.max_output_pressurec2))
    extra_pc2 = np.logspace(np.log10(low_pressurec2), np.log10(args.max_output_pressurec2), num+1)[1:]

else:
    raise ValueError('could not understand --pc2-scale=%s'%args.pc2_scale)

#------------------------

# set up covariance matrix
# note that we use the exact pressures from the input process

prior_cov_kwargs = dict(
    'pressurec2_scale'=args.pressurec2_scale,
    'correlation_length'=args.prior_correlation_length,
    'standard_deviation'=args.prior_standard_deviation,
### FIXME! add other parameters here
)

if args.verbose:
    print('computing prior covariance with')
    for key, val in prior_cov_kwargs.items():
        print('    '+key, val)

### input - input
prior_cov_input_input = kernel(input_pc2, input_pc2, **prior_cov_kwargs)

### input - extension and extension - input
prior_cov_input_extra = kernel(input_pc2, extra_pc2, **prior_cov_kwargs)
prior_cov_extra_input = np.transpose(prior_cov_input_extra)

### extension - extension
prior_cov_extra_extra = kernel(extra_pc2, extra_pc2, **prior_cov_kwargs)

#-------------------------------------------------

# figure out prior mean function
raise NotImplementedError('''\
implement mean of prior function
can we make this a zero-mean process (or just a simple linear trend) but then make the kernel the sum of a long-wavelength function and a short wavelength function?
this will avoid the ambiguity of picking a single mean function and sticking with it...
could help the prior avoid shoving everything to cs2 --> 1 at high densities?
''')

#-------------------------------------------------

# condition total GP on the input GP
raise NotImplementedError('condition the GP on both the input and the prior')

#------------------------

# save
raise NotImplementedError
