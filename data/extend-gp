#!/usr/bin/env python3

"""extend an existing GP model to higher densities and pressures
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os

import h5py
import numpy as np

from argparse import ArgumentParser

### non-standard library

import kernels

#-------------------------------------------------

parser = ArgumentParser()

#---

cgroup = parser.add_argument_group('arguments for process that we wish to extend')

cgroup.add_argument('input_hdf', type=str)
cgroup.add_argument('--max-input-pressurec2', default=None, type=float,
    help='truncate the input process to be below this pressure. Should be supplied in CGS units (g/cm^3)')

#---

egroup = parser.add_argument_group('arguments for extension to higher density')

egroup.add_argument('--pressurec2-scale', default='log', type=str,
    help='either "linear" or "log"; defines how we compute covariance kernel for extension to higher pressures')

egroup.add_argument('--max-output-pressurec2', default=1e17, type=float)
egroup.add_argument('--num-pressurec2-points-per-length', default=10, type=int,
    help='the number of grid points to be placed per correlation length in the extension to higher pressures')

egroup.add_argument('config', type=str,
    help='config for the properties of the GP extension')

#---

vgroup = parser.add_argument_group('output arguments')

vgroup.add_argument('--output-hdf', type=str, default=None)
vgroup.add_argument('-v', '--verbose', default=False, action='store_true')

#---

args = parser.parse_args()

if args.output_hdf is None:
    args.output_hdf = 'extended_'+os.path.basename(args.input_hdf)

#-------------------------------------------------

if args.verbose:
    print('loading : '+args.input_hdf)

with h5py.File(args.input_hdf, 'r') as obj:
    group = obj[list(obj.keys())[0]]

    attrs = dict(group.attrs.items())

    input_pc2 = np.mean(group['mean']['log(pressurec2)'][:])
    input_phi = group['mean']['phi'][:] # for the moment, stick with the assumption that the maximum sound speed is 1

    input_cov = group['cov'][...]

#------------------------

# truncated initial process at user-defined maximum pressure
if args.max_input_pressurec2 is not None:
    max_input_pc2 = np.max(mean_pc2)

    if max_input_pc2 > args.max_input_pressurec2:
        if args.verbose:
            print('truncating input pressurec2 to be <= %.6e g/cm^3'%args.max_input_pressurec2)
        keep = input_pc2 <= args.max_input_pressurec2

        input_pc2 = input_pc2[keep]
        input_phi = input_phi[keep]
        input_cov = input_cov[keep,keep]

    elif args.verbose:
        print('maximum input pressurece (%.6e g/cm^3) already less than requested maximum (%.6e g/cm^3)' % \
            (max_input_pc2, args.max_input_pressurec2))

#-------------------------------------------------

# now set up additional pressure grid
low_pressurec2 = np.max(mean_pc2)

if args.pressurec2_scale == 'linear':
    num = (args.max_output_pressurec2 - low_pressurec2) / args.prior_correlation_length
    num *= args.num_pressurec2_points_per_length
    if args.verbose:
        print('placing extension to higher pressures linearly with %d points between (%.6e, %.6e) g/cm^3' % \
            (num, low_pressurec2, args.max_output_pressurec2))
    extra_pc2 = np.linspace(low_pressurec2, args.max_output_pressurec2, num+1)[1:] ### do not repeat first point

elif args.pressurec2_scale == 'log':
    num = np.log(args.max_output_pressurec2 / low_pressurec2) / args.prior_correlation_length)
    num *= args.num_pressurec2_points_per_length
    if args.verbose:
        print('placing extension to higher pressures logarithmically with %d points between (%.6e, %.6e) g/cm^3' % \
            (num, low_pressurec2, args.max_output_pressurec2))
    extra_pc2 = np.logspace(np.log10(low_pressurec2), np.log10(args.max_output_pressurec2), num+1)[1:]

else:
    raise ValueError('could not understand --pc2-scale=%s'%args.pc2_scale)

#------------------------

# set up covariance matrix
# note that we use the exact pressures from the input process

if args.verbose:
    print('computing prior covariance matrix')

kernel = kernels.parse(args.config, verbose=args.verbose)

if args.pressurec2_scale == 'linear':
    input_x = input_pc2
    extra_x = extra_pc2

elif args.pressurec2_scale == 'log':
    input_x = np.log(input_pc2)
    extra_x = np.log(extra_pc2)

else:
    raise ValueError('--pressurec2-scale=%s not understood!' % args.pressurec2_scale)

raise NotImplementedError('fix this! need to set up my "test" points across the entire range...')

### input - input
prior_cov_input_input = kernel.cov(input_x, input_x)

### input - extension and extension - input
prior_cov_input_extra = kernel.cov(input_x, extra_x)
prior_cov_extra_input = np.transpose(prior_cov_input_extra)

### extension - extension
prior_cov_extra_extra = kernel.cov(extra_x, extra_x, **prior_cov_kwargs)

#-------------------------------------------------

# figure out prior mean function
# take this to be an extrapolation of the input process's behavior

if args.verbose:
    print('computing prior mean as a cubic fit to input process')

p3, p2, p1, p0 = np.polyfit(input_x, input_phi, 3) # use a 3rd order polynomial
                                         # will force phi to decrease as part of the extrapolation

input_mean = p3*input_x**3 + p2*input_x**2 + p1*input_x + p0
extra_mean = p3*extra_x**3 + p2*extra_x**2 + p1*extra_x + p0

#-------------------------------------------------

# condition total GP on the input GP

if args.verbose:
    print('conditioning prior process on input process')

raise NotImplementedError('condition the GP on both the input and the prior')

#------------------------

# save
if args.verbose:
    print('writing : '+args.output_hdf)

with h5py.File(args.output_hdf, 'w') as obj:
    group = obj.create_group(os.path.basename(args.input_hdf)[:-4])

    # store meta-data
    raise NotImplementedError

    # store process
    raise NotImplementedError
